#version 450 core

#include "extensions.glsl"
#include "common.glsl"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;
layout(constant_id = 1) const uint SAMPLE_COUNT = 4;
layout(constant_id = 2) const uint IMAGE_WIDTH = 1920;
layout(constant_id = 3) const uint IMAGE_HEIGHT = 1080;
layout(constant_id = 4) const float CAMERA_ORIGIN_X = 15.0;
layout(constant_id = 5) const float CAMERA_ORIGIN_Y = 15.0;
layout(constant_id = 6) const float CAMERA_ORIGIN_Z = 15.0;
layout(constant_id = 7) const float CAMERA_TARGET_X = 0.0;
layout(constant_id = 8) const float CAMERA_TARGET_Y = 4.0;
layout(constant_id = 9) const float CAMERA_TARGET_Z = 3.0;
layout(constant_id = 10) const float CAMERA_FOV = radians(50.0);

layout(push_constant) uniform PushData {
    uint pixel_index_offset;
    uint sample_index_offset;
    uint ray_pool_size;
} push_data;

void main()
{
    /* Reset counters to zero. */
    if (gl_GlobalInvocationID.x == 0)
    {
        path_segment_read_counter = 0;
        path_segment_write_counter = push_data.ray_pool_size;
    }

    memoryBarrierBuffer();

    if (gl_GlobalInvocationID.x > push_data.ray_pool_size)
    {
        return;
    }

    uint rng_state = wang_hash(gl_GlobalInvocationID.x);

    const uint local_ray_index = gl_GlobalInvocationID.x;
    const uint sample_index = (local_ray_index + push_data.sample_index_offset) % SAMPLE_COUNT;
    const uint pixel_index = push_data.pixel_index_offset +
        (local_ray_index + push_data.sample_index_offset) / SAMPLE_COUNT;

    const uvec2 pixel_pos = uvec2(pixel_index % IMAGE_WIDTH, pixel_index / IMAGE_WIDTH);

    /* Generate multiple rays originating from the camera. */
    const vec3 camera_origin = vec3(CAMERA_ORIGIN_X, CAMERA_ORIGIN_Y, CAMERA_ORIGIN_Z);
    const vec3 camera_target = vec3(CAMERA_TARGET_X, CAMERA_TARGET_Y, CAMERA_TARGET_Z);
    const vec3 camera_forward = normalize(camera_target - camera_origin);
    const vec3 camera_right = normalize(cross(camera_forward, vec3(0.0, 1.0, 0.0)));
    const vec3 camera_up = cross(camera_right, camera_forward);
    const float aspect_ratio = float(IMAGE_WIDTH) / float(IMAGE_HEIGHT);
    const float dist_to_plane = 1.0 / tan(CAMERA_FOV * 0.5);

    /* Find new point on camera plane with random offset. */
    const float r1 = random_float_between_0_and_1(rng_state);
    const float r2 = random_float_between_0_and_1(rng_state);
    const float norm_plane_pos_x = (float(pixel_pos.x) + r1) / float(IMAGE_WIDTH);
    const float norm_plane_pos_y = (float(pixel_pos.y) + r2) / float(IMAGE_HEIGHT);

    /* Convert from [0, 1] to [-1.0, 1.0] range. */
    const float centered_offset_x = (2.0 * norm_plane_pos_x) - 1.0;
    const float centered_offset_y = (2.0 * norm_plane_pos_y) - 1.0;

    /* Calculate ray properties. */
    const vec3 ray_origin = camera_origin;
    vec3 ray_direction =
        camera_right   * centered_offset_x * aspect_ratio +
        camera_up      * centered_offset_y +
        camera_forward * dist_to_plane;

    /* Beware: a single direction component must not be zero.
     * This is because we often take the inverse of the direction. */
    ray_direction += vec3(equal(ray_direction, vec3(0.0))) * FLOAT_MIN;
    ray_direction = normalize(ray_direction);

    path_segments[local_ray_index].origin = ray_origin;
    path_segments[local_ray_index].pixel_index = pixel_index;
    path_segments[local_ray_index].dir = ray_direction;
    path_segments[local_ray_index].throughput = vec3(1.0);

    /* We also set the initial pixel color. */
    if (sample_index == 0)
    {
        pixels[pixel_index * 4 + 0] = floatBitsToUint(0.0);
        pixels[pixel_index * 4 + 1] = floatBitsToUint(0.0);
        pixels[pixel_index * 4 + 2] = floatBitsToUint(0.0);
        pixels[pixel_index * 4 + 3] = floatBitsToUint(1.0);
    }
}
